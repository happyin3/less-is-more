# 线程原理

## 线程

什么是线程？

### 线程管理

线程控制表。

### 线程模型

推出线程模型的目的就是实现进程级并发。

线程的两种实现：

* 用户态实现：由进程自己管理。（灵活，线程切换快；进程级多道编程失效）
* 内核态实现：由操作系统管理。（用户编程简单；效率低（线程切换））

**用户态实现**

进程级多道编程失效：如果在执行过程中一个线程受阻，它将无法将控制权交出来，这样整个进程都无法推进。操作系统随机把CPU控制权交给其他进程。这样，一个线程受阻造成整个进程都受阻，我们期望通过线程对进程实施分身的计划就失败了。这是用户态线程的致命弱点。

既然线程阻塞造成整个进程阻塞，结局的办法只有两种：

* 不让线程阻塞。
* 阻塞后想办法激活同一进程的另外线程。

**现代操作系统的线程实现模型**

二者结合使用。用户态执行系统负责进程内部非阻塞时的切换；内核态的操作系统负责阻塞线程的切换。

## 线程同步

> 什么是线程同步?

同步就是让所有线程按照一定的规则执行，使得其正确性和效率都有迹可寻。

线程同步的目的就是不管线程之间的执行如何穿插，其运行结果都是正确的。或者说，要保证多线程执行下的结果的确定性。而在达到这个目标的同时，要保持对线程执行的限制越少越好。

### 锁

两个或多个线程争相执行同一段代码或访问同一资源的现象称为竞争。这个可能造成竞争的共享代码段或资源称为临界区。

sleep、wakeup原语：减少等锁的繁忙等待时间。

锁的问题：

* 死锁
* 信号丢失

### 信号量

信号量（semphore），可以说是所有原语里面功能最强大的。它不仅是一个同步原语，还是一个通信原语。

信号量就是一个计数器，其取值为当前累计的信号数量。它支持两个操作：加法操作up和down操作，分别描述如下：

down减法操作

1. 判断信号量的取值是否大于等于1.
2. 如果是，将信号量的值减去1，继续往下执行。
3. 否则在该信号量上等待（线程被挂起）。

up加法操作：

1. 将信号量的值增加1（此操作将叫醒一个在该信号量上面等待的线程）。
2. 线程继续往下执行。

这里需要注意的是，down和up两个操作虽然包含多个步骤，但这些步骤是一组原子操作。

**信号量存在程序编写困难或程序执行效率低下的问题。（信号量多的情况下）**

> 锁解决了同步问题，但带来的是循环等待，我们不满意。为了消除循环等待，我们发明了睡觉与叫醒。但睡觉与叫醒又带来了死锁。因此，我们发明了信号量。

### 管程

管程，monitor，即监视器的意思。它监视的就是进程或线程的同步操作。

管程是一个程序语言级别的构造，即它的正确运行由编译器负责保证。

在管程里面使用两种同步机制：锁用来互斥，条件变量用来控制执行的顺序。

管程里面的两个操作wait和signal的语义分别如下：

`wait(x)`以原子操作完成下述3个步骤：

1. 释放锁。
2. 将本线程挂在条件变量x的等待队列上。
3. 睡觉，等待被叫醒。

signal则与我们前面讲过的一样，将等待指定条件变量上面的第一个线程叫醒。在叫醒方面，管程还提供另外衣蛾所谓的广播（broadcast）原语，其语义是将指定条件变量上面的所有等待线程全部叫醒。

这里需要注意的是，在一个线程调用wait、signal或者broadcast之时，该线程必须持有与管程相连的锁。

HOARE管程：给予被叫醒者优先的管程。

MESA管程：叫醒者在发出signal后释放锁；被叫醒者与叫醒者同时竞争这把锁。谁先获得锁，谁先执行。

管程的问题：最大的问题时对编译器的依赖，因为我们需要编译器将需要的同步原语加在管程的开始和结尾。

### 消息传递

消息传递是通过同步双方经过相互收发消息来实现。它有两个基本操作，发送send和接收receive。它们均是操作系统的系统调用，而且既可以是阻塞调用，也可以是非阻塞调用。

消息传递的问题：最大的问题就是消息丢失和身份识别。

### 栅栏

栅栏就是一个障碍。到达栅栏的线程必须停止下来，直到除去栅栏后才能往前推进。该原语主要用来对一组线程进行协调。

## 死锁

死锁：如果有一组线程，每个线程都在等待一个事件的发生，而这个事件只能由该线程里面的另一线程发出，则称这组线程发生了死锁。

### 死锁的4个必要条件

1. 资源有限：即一个系统里面的资源数量有限，以致无法同时满足所有线程的资源需求。
2. 持有等待：即一个线程在请求新的资源时，其已经获得的资源并不释放，而是继续持有。
3. 不能抢占。
4. 循环等待。

### 死锁应对

两种策略：

* 允许死锁发生。
* 不让死锁发生。

**允许死锁发生**

* 假装没看见，不予理睬。
* 在死锁发生后，想办法予以解决。

**不让死锁发生**

* 通过生活中的仔细检点，避免难题出现。
* 通过将发生死锁的必要条件消除，杜绝死锁的发生。

**不予理睬**

> 世界上本没有问题，是你认为有问题，才有问题。

死锁发生的频率不太高，所以不必管它。另外，防止死锁的代价很高，因此不如重启。

**死锁检测与修复**

策略弊端较多：检测的时候发生了死锁、检测矩阵巨大严重消耗资源。

**死锁的动态避免**

动态避免：在每次进行资源分配时，必须经过仔细计算，确保资源请求批准后系统不会进入死锁或潜在的死锁状态。

**死锁的静态防止**

核心思想：清除死锁发生的土壤，而死锁发生的土壤就是死锁的4个必要条件。

* 消除资源的独占条件：资源共享。
* 消除保持和请求条件：一次请求所有资源、请求资源失败释放已持有资源。
* 消除非抢占条件：允许抢占资源。
* 消除循环等待条件：按顺序请求资源。

**银行家算法**

银行家算法，是仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法。该算法的策略是实现动态避免死锁。

## 锁的实现

操作系统之所以能够构建锁之类的同步原语，原因就是硬件已经为我们提供了一些原子操作：中断禁止与启用、内存加载和存入、测试与设置指令。在这些硬件原子操作之上，我们便可以构建软件原子操作：锁、睡觉和叫醒、信号量等。