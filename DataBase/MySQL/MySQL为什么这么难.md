# MySQL为什么这么难

* 存储引擎（数据存储）
* 增删改查（基础功能）
* 索引（加速查询）
* 锁（并发控制）
* 事务
* Buffer Pool（加速写入，异步刷盘）
* 日志-redo、binlog、undo
* MySQL必知必会
* 字符集
* EXPLAIN
* join

## MySQL Docker安装

## 锁

* 锁，锁的是什么？
* 锁是在哪一层实现的？
* 间隙锁，左右两个间隙怎么选？
* 不同索引，加锁规则（主键索引、普通索引、唯一索引）

### 锁的分类

* 共享锁（S锁）
* 排他锁（X锁）
* 共享意向锁（IS锁）
* 排他意向锁（IX锁）

* 全局锁
* 表锁
* 行锁

**行锁算法**

* 行锁
* 间隙锁
* next-key lock（“(]”前开后闭区间）

### 加锁规则

> 两个“原则”，两个“优化”，一个“bug”

1. 原则1：加锁的基本单位是next-key lock；
2. 原则2：查找过程中访问的对象才会加锁；
3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁；
4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满住足等值条件的时候，next-key lock退化为间隙锁；
5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

`select`默认不加锁。可以使用`lock in share mode`、`for update`主动加锁。

**锁是加在索引上的**，`lock in share mode`只锁覆盖索引，但是如果是`for update`就不一样了。执行`for update`时，系统会认为你接下来要更新数据，因此会顺便给主键索引上满足条件的行加上锁。

**在读提交隔离级别下还有一个优化**，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交。也就是说，读提交隔离级别下，锁的范围更小，锁的时间更短。

### 间隙锁

解决“幻读”的问题，所以只在“可重复读”隔离级别生效。

行锁之间存在冲突，但是间隙锁不一样，**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作**，间隙锁之间不存在冲突关系。

## 事务

* 事务完整的执行过程

### 隔离级别

* 读未提交（脏读）
* 读已提交（不可重复读、幻读）
* 可重复度
* 串行化

## 索引

## 高性能数据库表设计

* 三范式、反范式
* 数据类型